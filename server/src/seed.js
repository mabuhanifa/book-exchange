require("dotenv").config();
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs"); // Needed to hash passwords for dummy users
const User = require("./models/User");
const Book = require("./models/Book");
const ExchangeRequest = require("./models/ExchangeRequest");
const SellTransaction = require("./models/SellTransaction");
const BorrowRequest = require("./models/BorrowRequest");
const Review = require("./models/Review");
const Dispute = require("./models/Dispute");
const Notification = require("./models/Notification");
const Conversation = require("./models/Conversation");
const Message = require("./models/Message");
const RefreshToken = require("./models/RefreshToken"); // Although refresh tokens are usually generated by auth

const usersData = require("./data/users.json");
const booksData = require("./data/books.json");

const MONGODB_URI = process.env.MONGODB_URI;

const seedDatabase = async () => {
  try {
    await mongoose.connect(MONGODB_URI);
    console.log("MongoDB connected for seeding.");

    // --- Clear existing data (Optional but common for seeding) ---
    console.log("Clearing existing data...");
    await User.deleteMany();
    await Book.deleteMany();
    await ExchangeRequest.deleteMany();
    await SellTransaction.deleteMany();
    await BorrowRequest.deleteMany();
    await Review.deleteMany();
    await Dispute.deleteMany();
    await Notification.deleteMany();
    await Conversation.deleteMany();
    await Message.deleteMany();
    await RefreshToken.deleteMany();
    console.log("Existing data cleared.");

    // --- Drop potentially incorrect index on Reviews ---
    // This helps if a previous schema version created a unique index only on 'transaction'
    try {
      await Review.collection.dropIndex("transaction_1"); // Attempt to drop the index named 'transaction_1'
      console.log("Dropped index transaction_1 on reviews collection.");
    } catch (error) {
      // Ignore error if index doesn't exist (e.g., first time seeding)
      if (error.codeName !== "IndexNotFound") {
        console.warn(
          "Could not drop index transaction_1 (it might not exist):",
          error.message
        );
      } else {
        console.log("Index transaction_1 not found, no need to drop.");
      }
    }
    // Mongoose will recreate the correct index { reviewer: 1, transaction: 1 } when Review.create is called.

    // --- Seed Users ---
    console.log("Seeding users...");
    const createdUsers = await Promise.all(
      usersData.map(async (user) => {
        // Hash password if provided
        if (user.password) {
          const salt = await bcrypt.genSalt(10);
          user.password = await bcrypt.hash(user.password, salt);
        }
        // Hash OTP if provided (though OTP is usually temporary)
        if (user.otp) {
          const salt = await bcrypt.genSalt(10);
          user.otp = await bcrypt.hash(user.otp, salt);
        }
        return User.create(user);
      })
    );
    console.log(`${createdUsers.length} users seeded.`);

    // Map created users for easy lookup by phone number or name
    const userMap = {};
    createdUsers.forEach((user) => {
      userMap[user.phoneNumber] = user;
      userMap[user.name] = user; // Also map by name for convenience in books.json
    });

    // --- Seed Books ---
    console.log("Seeding books...");
    const createdBooks = await Promise.all(
      booksData.map(async (book) => {
        // Assign owner and area based on dummy data (assuming owner name is in booksData if needed, or distribute evenly)
        // For simplicity, let's assign books to Alice, Bob, Charlie users alternately
        const ownerUser = createdUsers[(booksData.indexOf(book) % 3) + 1]; // Skip Admin (index 0) and Unverified (index 4)
        book.owner = ownerUser._id;
        book.area = ownerUser.area; // Inherit area from owner

        return Book.create(book);
      })
    );
    console.log(`${createdBooks.length} books seeded.`);

    // Map created books for easy lookup
    const bookMap = {};
    createdBooks.forEach((book) => {
      bookMap[book.title] = book;
    });

    // --- Seed Transactions (Example: Create a few completed transactions) ---
    console.log("Seeding transactions...");
    const alice = userMap["Alice User"];
    const bob = userMap["Bob User"];
    const charlie = userMap["Charlie User"];
    const book1 = bookMap["The Alchemist"]; // Sell
    const book2 = bookMap["1984"]; // Exchange
    const book3 = bookMap["To Kill a Mockingbird"]; // Borrow
    const book4 = bookMap["Pride and Prejudice"]; // Sell
    const book5 = bookMap["The Great Gatsby"]; // Exchange (used in exchange with 1984)

    const createdTransactions = [];

    // Example Sell Transaction (Completed)
    if (alice && bob && book1) {
      const sellTx = await SellTransaction.create({
        seller: alice._id,
        buyer: bob._id,
        book: book1._id,
        price: book1.expectedPrice,
        status: "completed",
        paymentStatus: "paid",
        sellerConfirmedCompletion: true,
        buyerConfirmedCompletion: true,
        createdAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000), // 10 days ago
      });
      createdTransactions.push(sellTx);
      // Update book status
      book1.isAvailable = false;
      book1.status = "completed";
      await book1.save();
    }

    // Example Exchange Transaction (Completed)
    if (alice && charlie && book2 && book5) {
      const exchangeTx = await ExchangeRequest.create({
        requester: charlie._id,
        requesterBook: book5._id,
        owner: alice._id,
        ownerBook: book2._id,
        status: "completed",
        requesterConfirmedCompletion: true,
        ownerConfirmedCompletion: true,
        createdAt: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000), // 8 days ago
      });
      createdTransactions.push(exchangeTx);
      // Update book status
      book2.isAvailable = false;
      book2.status = "completed";
      book5.isAvailable = false;
      book5.status = "completed";
      await book2.save();
      await book5.save();
    }

    // Example Borrow Transaction (Active)
    if (bob && charlie && book3) {
      const borrowTx = await BorrowRequest.create({
        borrower: bob._id,
        owner: charlie._id,
        book: book3._id,
        requestedDuration: book3.borrowDuration,
        status: "active",
        borrowDate: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000), // Started 3 days ago
        dueDate: new Date(
          Date.now() + (book3.borrowDuration - 3) * 24 * 60 * 60 * 1000
        ), // Due in 11 days (14-3)
        createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000), // Created 5 days ago
      });
      createdTransactions.push(borrowTx);
      // Update book status
      book3.isAvailable = false;
      // book3.status = 'pending_borrow'; // Or 'active_borrow'
      await book3.save();
    }

    // Example Sell Transaction (Pending)
    if (charlie && alice && book4) {
      const pendingSellTx = await SellTransaction.create({
        seller: charlie._id,
        buyer: alice._id,
        book: book4._id,
        price: book4.expectedPrice,
        status: "pending",
        paymentStatus: "pending",
        createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000), // 1 day ago
      });
      createdTransactions.push(pendingSellTx);
      // Optional: Mark book as unavailable
      // book4.isAvailable = false;
      // book4.status = 'pending';
      // await book4.save();
    }

    console.log(`${createdTransactions.length} transactions seeded.`);

    // --- Seed Reviews (for completed transactions) ---
    console.log("Seeding reviews...");
    const createdReviews = [];
    // Review for the completed Sell Transaction (Bob reviews Alice)
    // Find the completed sell tx using instanceof and status
    const completedSellTx = createdTransactions.find(
      (tx) =>
        tx instanceof SellTransaction &&
        tx.status === "completed" &&
        tx.book.toString() === book1._id.toString()
    );
    if (completedSellTx) {
      const review1 = await Review.create({
        reviewer: bob._id,
        reviewee: alice._id,
        transaction: completedSellTx._id,
        transactionModel: "SellTransaction",
        rating: 5,
        comment: "Smooth transaction, book was as described!",
        createdAt: new Date(completedSellTx.updatedAt.getTime() + 1000), // Shortly after completion
      });
      createdReviews.push(review1);
      // Review for the completed Sell Transaction (Alice reviews Bob)
      const review2 = await Review.create({
        reviewer: alice._id,
        reviewee: bob._id,
        transaction: completedSellTx._id,
        transactionModel: "SellTransaction",
        rating: 4,
        comment: "Buyer was on time.",
        createdAt: new Date(completedSellTx.updatedAt.getTime() + 2000), // Shortly after completion
      });
      createdReviews.push(review2);
    }

    // Review for the completed Exchange Transaction (Charlie reviews Alice)
    // Find the completed exchange tx using instanceof and status
    const completedExchangeTx = createdTransactions.find(
      (tx) =>
        tx instanceof ExchangeRequest &&
        tx.status === "completed" &&
        tx.ownerBook.toString() === book2._id.toString() // This is line 241 in the original code block
    );
    if (completedExchangeTx) {
      const review3 = await Review.create({
        reviewer: charlie._id,
        reviewee: alice._id,
        transaction: completedExchangeTx._id,
        transactionModel: "ExchangeRequest",
        rating: 5,
        comment: "Great exchange!",
        createdAt: new Date(completedExchangeTx.updatedAt.getTime() + 1000), // Shortly after completion
      });
      createdReviews.push(review3);
      // Review for the completed Exchange Transaction (Alice reviews Charlie)
      const review4 = await Review.create({
        reviewer: alice._id,
        reviewee: charlie._id,
        transaction: completedExchangeTx._id,
        transactionModel: "ExchangeRequest",
        rating: 4,
        comment: "Book was okay.",
        createdAt: new Date(completedExchangeTx.updatedAt.getTime() + 2000), // Shortly after completion
      });
      createdReviews.push(review4);
    }

    console.log(`${createdReviews.length} reviews seeded.`);

    // --- Seed Disputes (Example: Create an open dispute) ---
    console.log("Seeding disputes...");
    // Example Dispute for the pending Sell Transaction
    const pendingSellTx = createdTransactions.find(
      (tx) =>
        tx instanceof SellTransaction && // Use instanceof
        tx.status === "pending" &&
        tx.book.toString() === book4._id.toString()
    );
    if (pendingSellTx) {
      const dispute1 = await Dispute.create({
        transaction: pendingSellTx._id,
        transactionModel: "SellTransaction",
        raisedBy: alice._id, // Buyer raises dispute
        participants: [alice._id, charlie._id],
        reason: "Seller is not responding to messages.",
        status: "open",
        createdAt: new Date(Date.now() - 12 * 60 * 60 * 1000), // 12 hours ago
      });
      // TODO: Update transaction status to 'disputed' if Dispute model doesn't handle it
      console.log("1 dispute seeded.");
    } else {
      console.log("No disputes seeded (pending sell transaction not found).");
    }

    // --- Seed Conversations and Messages (Example: For the pending sell transaction) ---
    console.log("Seeding conversations and messages...");
    if (pendingSellTx) {
      const transaction = pendingSellTx;
      const participants = [transaction.buyer, transaction.seller].sort(); // Alice and Charlie

      const conversation = await Conversation.create({
        transaction: transaction._id,
        transactionModel: "SellTransaction",
        participants: participants,
        lastMessageAt: new Date(),
      });

      await Message.create([
        {
          conversation: conversation._id,
          sender: transaction.buyer, // Alice
          text: "Hi, is this book still available?",
          readBy: participants,
          createdAt: new Date(Date.now() - 11 * 60 * 60 * 1000), // 11 hours ago
        },
        {
          conversation: conversation._id,
          sender: transaction.seller, // Charlie
          text: "Yes, it is.",
          readBy: participants,
          createdAt: new Date(Date.now() - 10 * 60 * 60 * 1000), // 10 hours ago
        },
        {
          conversation: conversation._id,
          sender: transaction.buyer, // Alice
          text: "Great! Can we meet tomorrow?",
          readBy: [transaction.buyer], // Alice read her own message
          createdAt: new Date(Date.now() - 9 * 60 * 60 * 1000), // 9 hours ago
        },
      ]);
      console.log("1 conversation and 3 messages seeded.");
    } else {
      console.log(
        "No conversations/messages seeded (pending sell transaction not found)."
      );
    }

    // --- Seed Notifications (Example: New review notification) ---
    console.log("Seeding notifications...");
    if (createdReviews[0]) {
      // Review from Bob to Alice
      await Notification.create({
        recipient: createdReviews[0].reviewee, // Alice
        type: "new_review",
        message: `You received a new review from ${bob.name}.`,
        entityType: "Review",
        entityId: createdReviews[0]._id,
        isRead: false,
        createdAt: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000), // After review creation
      });
      console.log("1 notification seeded.");
    } else {
      console.log("No notifications seeded (review not found).");
    }

    // Refresh Tokens are typically generated during login/refresh, not seeded directly.

    console.log("Database seeding complete!");
  } catch (error) {
    console.error("Error seeding database:", error);
    process.exit(1); // Exit with error code
  } finally {
    mongoose.connection.close();
    console.log("MongoDB connection closed.");
  }
};

// Run the seed function
seedDatabase();
